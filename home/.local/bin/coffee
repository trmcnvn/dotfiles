#!/usr/bin/env bash
# coffee - Keep your Mac coffee (Amphetamine alternative)
# Uses macOS built-in caffeinate

set -euo pipefail

PIDFILE="/tmp/coffee.pid"

usage() {
    cat <<EOF
Usage: coffee <command> [options]

Commands:
  start [duration]    Start keeping awake
                      duration: NUMBER[m|h] (e.g., 30m, 2h)
                      omit for indefinite
  
  stop                Stop current session
  status              Show current session status
  
  app <app_name>      Keep awake while app is running
                      e.g., coffee app "Google Chrome"
  
  pid <pid>           Keep awake while process is running
  
  until <HH:MM>       Keep awake until specific time (24h format)

Options:
  -d, --display-sleep    Allow display to sleep (default: display stays on)
  -h, --help             Show this help

Examples:
  coffee start            # Indefinitely, display on
  coffee start 30m        # 30 minutes
  coffee start 2h         # 2 hours
  coffee start -d         # Indefinitely, allow display sleep
  coffee app Safari       # While Safari is running
  coffee until 17:30      # Until 5:30 PM
  coffee stop             # End session
EOF
}

get_pid_for_app() {
    pgrep -x "$1" 2>/dev/null | head -1 || pgrep -f "$1" 2>/dev/null | head -1
}

stop_session() {
    if [[ -f "$PIDFILE" ]]; then
        pid=$(cat "$PIDFILE")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            echo "Session ended (was PID $pid)"
        else
            echo "No active session"
        fi
        rm -f "$PIDFILE"
    else
        # Try to kill any caffeinate started by us
        pkill -f "caffeinate" 2>/dev/null && echo "Session ended" || echo "No active session"
    fi
}

show_status() {
    if [[ -f "$PIDFILE" ]]; then
        pid=$(cat "$PIDFILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo "Session active (PID $pid)"
            # Show process info
            ps -p "$pid" -o etime=,command= 2>/dev/null | sed 's/^ */  Elapsed: /' || true
            return 0
        fi
    fi
    echo "No active session"
    return 1
}

start_caffeinate() {
    local flags="$1"
    local timeout="${2:-}"
    
    stop_session 2>/dev/null || true
    
    if [[ -n "$timeout" ]]; then
        caffeinate $flags -t "$timeout" &
        echo "Keeping coffee for $((timeout / 60)) minutes"
    else
        caffeinate $flags &
        echo "Keeping coffee indefinitely"
    fi
    
    echo $! > "$PIDFILE"
    echo "Session started (PID $!)"
    echo "Run 'coffee stop' to end"
}

wait_for_pid() {
    local target_pid="$1"
    local flags="$2"
    
    if ! kill -0 "$target_pid" 2>/dev/null; then
        echo "Process $target_pid not found"
        exit 1
    fi
    
    stop_session 2>/dev/null || true
    
    caffeinate $flags -w "$target_pid" &
    echo $! > "$PIDFILE"
    echo "Keeping coffee while PID $target_pid runs"
    echo "Session started (PID $!)"
}

parse_duration() {
    local input="$1"
    local num="${input%[mhMH]}"
    local unit="${input##*[0-9]}"
    
    if ! [[ "$num" =~ ^[0-9]+$ ]]; then
        echo "Invalid duration: $input" >&2
        exit 1
    fi
    
    case "$unit" in
        m|M) echo $((num * 60)) ;;
        h|H) echo $((num * 3600)) ;;
        "")  echo $((num * 60)) ;;  # default to minutes
        *)   echo "Invalid unit: $unit (use m or h)" >&2; exit 1 ;;
    esac
}

calc_until_seconds() {
    local target="$1"
    local target_ts now_ts diff
    
    target_ts=$(date -j -f "%H:%M" "$target" "+%s" 2>/dev/null) || {
        echo "Invalid time format. Use HH:MM (24h)" >&2
        exit 1
    }
    now_ts=$(date "+%s")
    diff=$((target_ts - now_ts))
    
    # If time has passed, assume tomorrow
    if [[ $diff -le 0 ]]; then
        diff=$((diff + 86400))
    fi
    
    echo "$diff"
}

# Default: prevent both system and display sleep
FLAGS="-di"

# Parse global options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -d|--display-sleep)
            FLAGS="-i"  # Only prevent idle sleep, allow display sleep
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            break
            ;;
    esac
done

cmd="${1:-}"
shift || true

case "$cmd" in
    start)
        if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
            timeout=$(parse_duration "$1")
            start_caffeinate "$FLAGS" "$timeout"
        else
            start_caffeinate "$FLAGS"
        fi
        ;;
    stop)
        stop_session
        ;;
    status)
        show_status
        ;;
    app)
        [[ $# -lt 1 ]] && { echo "Usage: coffee app <app_name>"; exit 1; }
        app_pid=$(get_pid_for_app "$1")
        [[ -z "$app_pid" ]] && { echo "App '$1' not running"; exit 1; }
        wait_for_pid "$app_pid" "$FLAGS"
        echo "Tracking app: $1"
        ;;
    pid)
        [[ $# -lt 1 ]] && { echo "Usage: coffee pid <pid>"; exit 1; }
        wait_for_pid "$1" "$FLAGS"
        ;;
    until)
        [[ $# -lt 1 ]] && { echo "Usage: coffee until <HH:MM>"; exit 1; }
        secs=$(calc_until_seconds "$1")
        start_caffeinate "$FLAGS" "$secs"
        echo "Until $1 (~$((secs / 60)) minutes)"
        ;;
    "")
        usage
        exit 1
        ;;
    *)
        echo "Unknown command: $cmd"
        usage
        exit 1
        ;;
esac
